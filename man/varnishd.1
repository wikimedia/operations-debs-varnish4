.\" Man page generated from reStructeredText.
.
.TH VARNISHD 1 "" "" ""
.SH NAME
varnishd \- HTTP accelerator daemon
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.sp
varnishd [\-a address[:port][,PROTO]] [\-b host[:port]] [\-C] [\-d] [\-F] [\-f config] [\-h type[,options]] [\-i identity] [\-j jail[,jailoptions]] [\-l vsl[,vsm]] [\-M address:port] [\-n name] [\-P file] [\-p param=value] [\-r param[,param...]] [\-S secret\-file] [\-s [name=]kind[,options]] [\-T address[:port]] [\-t TTL] [\-V] [\-W waiter]
.SH DESCRIPTION
.sp
The \fIvarnishd\fP daemon accepts HTTP requests from clients, passes them on
to a backend server and caches the returned documents to better
satisfy future requests for the same document.
.SH OPTIONS
.INDENT 0.0
.TP
.BI \-a \ <address[:port][,PROTO]>
Listen for client requests on the specified address and port. The
address can be a host name ("localhost"), an IPv4 dotted\-quad
("127.0.0.1"), or an IPv6 address enclosed in square brackets
("[::1]"). If address is not specified, \fIvarnishd\fP will listen on all
available IPv4 and IPv6 interfaces. If port is not specified, port
80 (http) is used.
An additional protocol type can be set for the listening socket with PROTO.
Valid protocol types are: HTTP/1 (default), and PROXY.
Multiple listening addresses can be specified by using multiple \-a arguments.
.TP
.BI \-b \ <host[:port]>
Use the specified host as backend server. If port is not specified,
the default is 8080.
.TP
.B \-C
Print VCL code compiled to C language and exit. Specify the VCL file
to compile with the \-f option.
.TP
.B \-d
Enables debugging mode: The parent process runs in the foreground
with a CLI connection on stdin/stdout, and the child process must be
started explicitly with a CLI command. Terminating the parent
process will also terminate the child.
.TP
.B \-F
Do not fork, run in the foreground.
.TP
.BI \-f \ config
Use the specified VCL configuration file instead of the builtin
default.  See \fIvcl(7)\fP for details on VCL syntax.
.sp
When neither a \-f nor a \-b argument are given, \fIvarnishd\fP will not
start the worker process but process cli commands.
.TP
.BI \-h \ <type[,options]>
Specifies the hash algorithm. See \fI\%Hash Algorithm Options\fP for a
list of supported algorithms.
.TP
.BI \-i \ identity
Specify the identity of the Varnish server. This can be accessed
using \fBserver.identity\fP from VCL.
.TP
.BI \-j \ <jail[,jailoptions]>
Specify the jailing technology to use.
.TP
.BI \-l \ <vsl[,vsm]>
Specifies size of shmlog file. vsl is the space for the VSL records
[80M] and vsm is the space for stats counters [1M]. Scaling suffixes
like \(aqK\(aq and \(aqM\(aq can be used up to (G)igabytes.
Default is 81 Megabytes.
.TP
.BI \-M \ <address:port>
Connect to this port and offer the command line interface.  Think of
it as a reverse shell. When running with \-M and there is no backend
defined the child process (the cache) will not start initially.
.TP
.BI \-n \ name
Specify the name for this instance.  Amongst other things, this name
is used to construct the name of the directory in which \fIvarnishd\fP
keeps temporary files and persistent state. If the specified name
begins with a forward slash, it is interpreted as the absolute path
to the directory which should be used for this purpose.
.TP
.BI \-P \ file
Write the PID of the process to the specified file.
.TP
.BI \-p \ <param=value>
Set the parameter specified by param to the specified value, see
\fI\%List of Parameters\fP for details. This option can be used multiple
times to specify multiple parameters.
.TP
.BI \-r \ <param[,param...]>
Make the listed parameters read only. This gives the system
administrator a way to limit what the Varnish CLI can do.  Consider
making parameters such as \fIcc_command\fP, \fIvcc_allow_inline_c\fP and
\fIvmod_dir\fP read only as these can potentially be used to escalate
privileges from the CLI.
.TP
.BI \-S \ file
Path to a file containing a secret used for authorizing access to
the management port. If not provided a new secret will be drawn
from the system PRNG.
.TP
.BI \-s \ <[name=]type[,options]>
Use the specified storage backend, see \fI\%Storage Backend Options\fP.
.sp
This option can be used multiple times to specify multiple storage
files. Names are referenced in logs, VCL, statistics, etc.
.TP
.BI \-T \ <address[:port]>
Offer a management interface on the specified address and port. See
\fI\%Management Interface\fP for a list of management commands.
.TP
.BI \-t \ TTL
Specifies the default time to live (TTL) for cached objects. This is
a shortcut for specifying the \fIdefault_ttl\fP run\-time parameter.
.TP
.B \-V
Display the version number and exit.
.TP
.BI \-W \ waiter
Specifies the waiter type to use.
.UNINDENT
.SS Hash Algorithm Options
.sp
The following hash algorithms are available:
.INDENT 0.0
.TP
.BI \-h \ critbit
self\-scaling tree structure. The default hash algorithm in Varnish
Cache 2.1 and onwards. In comparison to a more traditional B tree
the critbit tree is almost completely lockless. Do not change this
unless you are certain what you\(aqre doing.
.TP
.BI \-h \ simple_list
A simple doubly\-linked list.  Not recommended for production use.
.TP
.BI \-h \ <classic[,buckets]>
A standard hash table. The hash key is the CRC32 of the object\(aqs URL
modulo the size of the hash table.  Each table entry points to a
list of elements which share the same hash key. The buckets
parameter specifies the number of entries in the hash table.  The
default is 16383.
.UNINDENT
.SS Storage Backend Options
.sp
The following storage types are available:
.INDENT 0.0
.TP
.BI \-s \ <malloc[,size]>
malloc is a memory based backend.
.TP
.BI \-s \ <file,path[,size[,granularity]]>
The file backend stores data in a file on disk. The file will be
accessed using mmap.
.sp
The path is mandatory. If path points to a directory, a temporary
file will be created in that directory and immediately unlinked. If
path points to a non\-existing file, the file will be created.
.sp
If size is omitted, and path points to an existing file with a size
greater than zero, the size of that file will be used. If not, an
error is reported.
.sp
Granularity sets the allocation block size. Defaults to the system
page size or the filesystem block size, whichever is larger.
.TP
.BI \-s \ <persistent,path,size>
Persistent storage. Varnish will store objects in a file in a manner
that will secure the survival of \fImost\fP of the objects in the event
of a planned or unplanned shutdown of Varnish. The persistent
storage backend has multiple issues with it and will likely be
removed from a future version of Varnish.
.UNINDENT
.SS Jail Options
.sp
Varnish jails are a generalization over various platform specific
methods to reduce the privileges of varnish processes. They may have
specific options. Available jails are:
.INDENT 0.0
.TP
.BI \-j \ solaris
Reduce privileges(5) for \fIvarnishd\fP and sub\-process to the minimally
required set. Only available on platforms which have the setppriv(2)
call.
.TP
.BI \-j \ <unix[,user=\(gauser\(ga][,ccgroup=\(gagroup\(ga]>
Default on all other platforms if \fIvarnishd\fP is either started with
an effective uid of 0 ("as root") or as user \fBvarnish\fP.
.sp
With the \fBunix\fP jail technology activated, varnish will switch to
an alternative user for subprocesses and change the effective uid of
the master process whenever possible.
.sp
The optional \fIuser\fP argument specifies which alternative user to
use. It defaults to \fBvarnish\fP
.sp
The optional \fIccgroup\fP argument specifies a group to add to varnish
subprocesses requiring access to a c\-compiler. There is no default.
.TP
.BI \-j \ none
last resort jail choice: With jail technology \fBnone\fP, varnish will
run all processes with the privileges it was started with.
.UNINDENT
.SS Management Interface
.sp
If the \-T option was specified, \fIvarnishd\fP will offer a command\-line
management interface on the specified address and port.  The
recommended way of connecting to the command\-line management interface
is through varnishadm(1).
.sp
The commands available are documented in varnish(7).
.SH RUN TIME PARAMETERS
.SS Run Time Parameter Flags
.sp
Runtime parameters are marked with shorthand flags to avoid repeating
the same text over and over in the table below. The meaning of the
flags are:
.INDENT 0.0
.IP \(bu 2
\fIexperimental\fP
.sp
We have no solid information about good/bad/optimal values for this
parameter. Feedback with experience and observations are most
welcome.
.IP \(bu 2
\fIdelayed\fP
.sp
This parameter can be changed on the fly, but will not take effect
immediately.
.IP \(bu 2
\fIrestart\fP
.sp
The worker process must be stopped and restarted, before this
parameter takes effect.
.IP \(bu 2
\fIreload\fP
.sp
The VCL programs must be reloaded for this parameter to take effect.
.IP \(bu 2
\fIexperimental\fP
.sp
We\(aqre not really sure about this parameter, tell us what you find.
.IP \(bu 2
\fIwizard\fP
.sp
Do not touch unless you \fIreally\fP know what you\(aqre doing.
.IP \(bu 2
\fIonly_root\fP
.sp
Only works if \fIvarnishd\fP is running as root.
.UNINDENT
.SS Default Value Exceptions on 32 bit Systems
.sp
Be aware that on 32 bit systems, certain default values are reduced
relative to the values listed below, in order to conserve VM space:
.INDENT 0.0
.IP \(bu 2
workspace_client: 16k
.IP \(bu 2
thread_pool_workspace: 16k
.IP \(bu 2
http_resp_size: 8k
.IP \(bu 2
http_req_size: 12k
.IP \(bu 2
gzip_stack_buffer: 4k
.IP \(bu 2
thread_pool_stack: 64k
.UNINDENT
.SS List of Parameters
.sp
This text is produced from the same text you will find in the CLI if
you use the param.show command:
.\" The following is the autogenerated output from varnishd -x dumprstparam
.
.SS accept_filter
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: off
.IP \(bu 2
Flags: must_restart
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Enable kernel accept\-filters (if available in the kernel).
.SS acceptor_sleep_decay
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 0.9
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Maximum: 1
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If we run out of resources, such as file descriptors or worker threads, the acceptor will sleep between accepts.
This parameter (multiplicatively) reduce the sleep duration for each successful accept. (ie: 0.9 = reduce by 10%)
.SS acceptor_sleep_incr
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Maximum: 1.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If we run out of resources, such as file descriptors or worker threads, the acceptor will sleep between accepts.
This parameter control how much longer we sleep, each time we fail to accept a new connection.
.SS acceptor_sleep_max
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.050
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Maximum: 10.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If we run out of resources, such as file descriptors or worker threads, the acceptor will sleep between accepts.
This parameter limits how long it can sleep between attempts to accept new connections.
.SS auto_restart
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Automatically restart the child/worker process if it dies.
.SS backend_idle_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 1.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Timeout before we close unused backend connections.
.SS ban_dups
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Eliminate older identical bans when a new ban is added.  This saves CPU cycles by not comparing objects to identical bans.
This is a waste of time if you have many bans which are never identical.
.SS ban_lurker_age
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The ban lurker will ignore bans until they are this old.  When a ban is added, the active traffic will be tested against it as part of object lookup.  This parameter holds the ban\-lurker off, until the rush is over.
.SS ban_lurker_batch
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 1000
.IP \(bu 2
Minimum: 1
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The ban lurker sleeps ${ban_lurker_sleep} after examining this many objects.  Use this to pace the ban\-lurker if it eats too many resources.
.SS ban_lurker_sleep
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.010
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
How long the ban lurker sleeps after examining ${ban_lurker_batch} objects.  Use this to pace the ban\-lurker if it eats too many resources.
A value of zero will disable the ban lurker entirely.
.SS between_bytes_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
We only wait for this many seconds between bytes received from the backend before giving up the fetch.
A value of zero means never give up.
VCL values, per backend or per backend request take precedence.
This parameter does not apply to pipe\(aqed requests.
.SS cc_command
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: "exec gcc \-std=gnu99 \-g \-O2 \-Wall \-Werror \-Wno\-error=unused\-result  t\-Werror t\-Wall t\-Wno\-format\-y2k t\-W t\-Wstrict\-prototypes t\-Wmissing\-prototypes t\-Wpointer\-arith t\-Wreturn\-type t\-Wcast\-qual t\-Wwrite\-strings t\-Wswitch t\-Wshadow t\-Wunused\-parameter t\-Wcast\-align t\-Wchar\-subscripts t\-Wnested\-externs t\-Wextra t\-Wno\-sign\-compare  \-fstack\-protector \-Wno\-pointer\-sign \-Wno\-address \-Wno\-missing\-field\-initializers \-pthread \-fpic \-shared \-Wl,\-x \-o %o %s"
.IP \(bu 2
Flags: must_reload
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Command used for compiling the C source code to a dlopen(3) loadable object.  Any occurrence of %s in the string will be replaced with the source file name, and %o will be replaced with the output file name.
.SS cli_buffer
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 8k
.IP \(bu 2
Minimum: 4k
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Size of buffer for CLI command input.
You may need to increase this if you have big VCL files and use the vcl.inline CLI command.
NB: Must be specified with \-p to have effect.
.SS cli_limit
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 48k
.IP \(bu 2
Minimum: 128b
.IP \(bu 2
Maximum: 99999999b
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum size of CLI response.  If the response exceeds this limit, the response code will be 201 instead of 200 and the last line will indicate the truncation.
.SS cli_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Timeout for the childs replies to CLI requests from the mgt_param.
.SS clock_skew
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 10
.IP \(bu 2
Minimum: 0
.UNINDENT
.UNINDENT
.UNINDENT
.sp
How much clockskew we are willing to accept between the backend and our own clock.
.SS connect_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 3.500
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Default connection timeout for backend connections. We only try to connect to the backend for this many seconds before giving up. VCL can override this default value for each backend and backend request.
.SS critbit_cooloff
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 180.000
.IP \(bu 2
Minimum: 60.000
.IP \(bu 2
Maximum: 254.000
.IP \(bu 2
Flags: wizard
.UNINDENT
.UNINDENT
.UNINDENT
.sp
How long the critbit hasher keeps deleted objheads on the cooloff list.
.SS debug
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: none
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Enable/Disable various kinds of debugging.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fInone\fP
Disable all debugging
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Use +/\- prefix to set/reset individual bits:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fIreq_state\fP
VSL Request state engine
.TP
.B \fIworkspace\fP
VSL Workspace operations
.TP
.B \fIwaiter\fP
VSL Waiter internals
.TP
.B \fIwaitinglist\fP
VSL Waitinglist events
.TP
.B \fIsyncvsl\fP
Make VSL synchronous
.TP
.B \fIhashedge\fP
Edge cases in Hash
.TP
.B \fIvclrel\fP
Rapid VCL release
.TP
.B \fIlurker\fP
VSL Ban lurker
.TP
.B \fIesi_chop\fP
Chop ESI fetch to bits
.TP
.B \fIflush_head\fP
Flush after http1 head
.TP
.B \fIvtc_mode\fP
Varnishtest Mode
.TP
.B \fIwitness\fP
Emit WITNESS lock records
.TP
.B \fIvsm_keep\fP
Keep the VSM file on restart
.UNINDENT
.UNINDENT
.UNINDENT
.SS default_grace
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 10.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: obj_sticky
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Default grace period.  We will deliver an object this long after it has expired, provided another thread is attempting to get a new copy.
.SS default_keep
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: obj_sticky
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Default keep period.  We will keep a useless object around this long, making it available for conditional backend fetches.  That means that the object will be removed from the cache at the end of ttl+grace+keep.
.SS default_ttl
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 120.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: obj_sticky
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The TTL assigned to objects if neither the backend nor the VCL code assigns one.
.SS feature
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: none
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Enable/Disable various minor features.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fInone\fP
Disable all features.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Use +/\- prefix to enable/disable individual feature:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fIshort_panic\fP
Short panic message.
.TP
.B \fIwait_silo\fP
Wait for persistent silo.
.TP
.B \fIno_coredump\fP
No coredumps.
.TP
.B \fIesi_ignore_https\fP
Treat HTTPS as HTTP in ESI:includes
.TP
.B \fIesi_disable_xml_check\fP
Don\(aqt check of body looks like XML
.TP
.B \fIesi_ignore_other_elements\fP
Ignore non\-esi XML\-elements
.TP
.B \fIesi_remove_bom\fP
Remove UTF\-8 BOM
.TP
.B \fIhttps_scheme\fP
Also split https URIs
.UNINDENT
.UNINDENT
.UNINDENT
.SS fetch_chunksize
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 16k
.IP \(bu 2
Minimum: 4k
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The default chunksize used by fetcher. This should be bigger than the majority of objects with short TTLs.
Internal limits in the storage_file module makes increases above 128kb a dubious idea.
.SS fetch_maxchunksize
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 0.25G
.IP \(bu 2
Minimum: 64k
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The maximum chunksize we attempt to allocate from storage. Making this too large may cause delays and storage fragmentation.
.SS first_byte_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Default timeout for receiving first byte from backend. We only wait for this many seconds for the first byte before giving up. A value of 0 means it will never time out. VCL can override this default value for each backend and backend request. This parameter does not apply to pipe.
.SS gzip_buffer
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 32k
.IP \(bu 2
Minimum: 2k
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Size of malloc buffer used for gzip processing.
These buffers are used for in\-transit data, for instance gunzip\(aqed data being sent to a client.Making this space to small results in more overhead, writes to sockets etc, making it too big is probably just a waste of memory.
.SS gzip_level
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 6
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Maximum: 9
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Gzip compression level: 0=debug, 1=fast, 9=best
.SS gzip_memlevel
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 8
.IP \(bu 2
Minimum: 1
.IP \(bu 2
Maximum: 9
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Gzip memory level 1=slow/least, 9=fast/most compression.
Memory impact is 1=1k, 2=2k, ... 9=256k.
.SS http_gzip_support
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B Enable gzip support. When enabled Varnish request compressed objects from the backend and store them compressed. If a client does not support gzip encoding Varnish will uncompress compressed objects on demand. Varnish will also rewrite the Accept\-Encoding header of clients indicating support for gzip to:
Accept\-Encoding: gzip
.UNINDENT
.sp
Clients that do not support gzip will have their Accept\-Encoding header removed. For more information on how gzip is implemented please see the chapter on gzip in the Varnish reference.
.SS http_max_hdr
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: header lines
.IP \(bu 2
Default: 64
.IP \(bu 2
Minimum: 32
.IP \(bu 2
Maximum: 65535
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum number of HTTP header lines we allow in {req|resp|bereq|beresp}.http (obj.http is autosized to the exact number of headers).
Cheap, ~20 bytes, in terms of workspace memory.
Note that the first line occupies five header lines.
.SS http_range_support
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Enable support for HTTP Range headers.
.SS http_req_hdr_len
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 8k
.IP \(bu 2
Minimum: 40b
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum length of any HTTP client request header we will allow.  The limit is inclusive its continuation lines.
.SS http_req_size
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 32k
.IP \(bu 2
Minimum: 0.25k
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum number of bytes of HTTP client request we will deal with.  This is a limit on all bytes up to the double blank line which ends the HTTP request.
The memory for the request is allocated from the client workspace (param: workspace_client) and this parameter limits how much of that the request is allowed to take up.
.SS http_resp_hdr_len
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 8k
.IP \(bu 2
Minimum: 40b
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum length of any HTTP backend response header we will allow.  The limit is inclusive its continuation lines.
.SS http_resp_size
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 32k
.IP \(bu 2
Minimum: 0.25k
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum number of bytes of HTTP backend response we will deal with.  This is a limit on all bytes up to the double blank line which ends the HTTP request.
The memory for the request is allocated from the backend workspace (param: workspace_backend) and this parameter limits how much of that the request is allowed to take up.
.SS idle_send_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Time to wait with no data sent. If no data has been transmitted in this many
seconds the session is closed.
See setsockopt(2) under SO_SNDTIMEO for more information.
.SS listen_depth
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: connections
.IP \(bu 2
Default: 1024
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Flags: must_restart
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Listen queue depth.
.SS lru_interval
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 2.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Grace period before object moves on LRU list.
Objects are only moved to the front of the LRU list if they have not been moved there already inside this timeout period.  This reduces the amount of lock operations necessary for LRU list access.
.SS max_esi_depth
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: levels
.IP \(bu 2
Default: 5
.IP \(bu 2
Minimum: 0
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum depth of esi:include processing.
.SS max_restarts
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: restarts
.IP \(bu 2
Default: 4
.IP \(bu 2
Minimum: 0
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Upper limit on how many times a request can restart.
Be aware that restarts are likely to cause a hit against the backend, so don\(aqt increase thoughtlessly.
.SS max_retries
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: retries
.IP \(bu 2
Default: 4
.IP \(bu 2
Minimum: 0
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Upper limit on how many times a backend fetch can retry.
.SS nuke_limit
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: allocations
.IP \(bu 2
Default: 50
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum number of objects we attempt to nuke in order to make space for a object body.
.SS pcre_match_limit
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 10000
.IP \(bu 2
Minimum: 1
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The limit for the number of calls to the internal match() function in pcre_exec().
.sp
(See: PCRE_EXTRA_MATCH_LIMIT in pcre docs.)
.sp
This parameter limits how much CPU time regular expression matching can soak up.
.SS pcre_match_limit_recursion
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 20
.IP \(bu 2
Minimum: 1
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The recursion depth\-limit for the internal match() function in a pcre_exec().
.sp
(See: PCRE_EXTRA_MATCH_LIMIT_RECURSION in pcre docs.)
.sp
This puts an upper limit on the amount of stack used by PCRE for certain classes of regular expressions.
.sp
We have set the default value low in order to prevent crashes, at the cost of possible regexp matching failures.
.sp
Matching failures will show up in the log as VCL_Error messages with regexp errors \-27 or \-21.
.sp
Testcase r01576 can be useful when tuning this parameter.
.SS ping_interval
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 3
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Flags: must_restart
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Interval between pings from parent to child.
Zero will disable pinging entirely, which makes it possible to attach a debugger to the child.
.SS pipe_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 60.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Idle timeout for PIPE sessions. If nothing have been received in either direction for this many seconds, the session is closed.
.SS pool_req
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 10,100,10
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Parameters for per worker pool request memory pool.
The three numbers are:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fImin_pool\fP
minimum size of free pool.
.TP
.B \fImax_pool\fP
maximum size of free pool.
.TP
.B \fImax_age\fP
max age of free element.
.UNINDENT
.UNINDENT
.UNINDENT
.SS pool_sess
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 10,100,10
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Parameters for per worker pool session memory pool.
The three numbers are:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fImin_pool\fP
minimum size of free pool.
.TP
.B \fImax_pool\fP
maximum size of free pool.
.TP
.B \fImax_age\fP
max age of free element.
.UNINDENT
.UNINDENT
.UNINDENT
.SS pool_vbo
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 10,100,10
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Parameters for backend object fetch memory pool.
The three numbers are:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fImin_pool\fP
minimum size of free pool.
.TP
.B \fImax_pool\fP
maximum size of free pool.
.TP
.B \fImax_age\fP
max age of free element.
.UNINDENT
.UNINDENT
.UNINDENT
.SS prefer_ipv6
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: off
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Prefer IPv6 address when connecting to backends which have both IPv4 and IPv6 addresses.
.SS rush_exponent
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: requests per request
.IP \(bu 2
Default: 3
.IP \(bu 2
Minimum: 2
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
How many parked request we start for each completed request on the object.
NB: Even with the implict delay of delivery, this parameter controls an exponential increase in number of worker threads.
.SS send_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 600.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Send timeout for client connections. If the HTTP response hasn\(aqt been transmitted in this many
seconds the session is closed.
See setsockopt(2) under SO_SNDTIMEO for more information.
.SS session_max
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: sessions
.IP \(bu 2
Default: 100000
.IP \(bu 2
Minimum: 1000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum number of sessions we will allocate from one pool before just dropping connections.
This is mostly an anti\-DoS measure, and setting it plenty high should not hurt, as long as you have the memory for it.
.SS shm_reclen
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 255b
.IP \(bu 2
Minimum: 16b
.IP \(bu 2
Maximum: 4084
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Old name for vsl_reclen, use that instead.
.SS shortlived
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 10.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Objects created with (ttl+grace+keep) shorter than this are always put in transient storage.
.SS sigsegv_handler
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.IP \(bu 2
Flags: must_restart
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Install a signal handler which tries to dump debug information on segmentation faults, bus errors and abort signals.
.SS syslog_cli_traffic
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Log all CLI traffic to syslog(LOG_INFO).
.SS tcp_keepalive_intvl
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 75.000
.IP \(bu 2
Minimum: 1.000
.IP \(bu 2
Maximum: 100.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The number of seconds between TCP keep\-alive probes.
.SS tcp_keepalive_probes
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: probes
.IP \(bu 2
Default: 9
.IP \(bu 2
Minimum: 1
.IP \(bu 2
Maximum: 100
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The maximum number of TCP keep\-alive probes to send before giving up and killing the connection if no response is obtained from the other end.
.SS tcp_keepalive_time
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 7200.000
.IP \(bu 2
Minimum: 1.000
.IP \(bu 2
Maximum: 7200.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The number of seconds a connection needs to be idle before TCP begins sending out keep\-alive probes.
.SS thread_pool_add_delay
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.000
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Wait at least this long after creating a thread.
.sp
Some (buggy) systems may need a short (sub\-second) delay between creating threads.
Set this to a few milliseconds if you see the \(aqthreads_failed\(aq counter grow too much.
.sp
Setting this too high results in insuffient worker threads.
.SS thread_pool_destroy_delay
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 1.000
.IP \(bu 2
Minimum: 0.010
.IP \(bu 2
Flags: delayed, experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Wait this long after destroying a thread.
.sp
This controls the decay of thread pools when idle(\-ish).
.SS thread_pool_fail_delay
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.200
.IP \(bu 2
Minimum: 0.010
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Wait at least this long after a failed thread creation before trying to create another thread.
.sp
Failure to create a worker thread is often a sign that  the end is near, because the process is running out of some resource.  This delay tries to not rush the end on needlessly.
.sp
If thread creation failures are a problem, check that thread_pool_max is not too high.
.sp
It may also help to increase thread_pool_timeout and thread_pool_min, to reduce the rate at which treads are destroyed and later recreated.
.SS thread_pool_max
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: threads
.IP \(bu 2
Default: 5000
.IP \(bu 2
Minimum: 100
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The maximum number of worker threads in each pool.
.sp
Do not set this higher than you have to, since excess worker threads soak up RAM and CPU and generally just get in the way of getting work done.
.SS thread_pool_min
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: threads
.IP \(bu 2
Default: 100
.IP \(bu 2
Maximum: 5000
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The minimum number of worker threads in each pool.
.sp
Increasing this may help ramp up faster from low load situations or when threads have expired.
.sp
Minimum is 10 threads.
.SS thread_pool_stack
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 48k
.IP \(bu 2
Minimum: 16k
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Worker thread stack size.
This will likely be rounded up to a multiple of 4k (or whatever the page_size might be) by the kernel.
.SS thread_pool_timeout
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 300.000
.IP \(bu 2
Minimum: 10.000
.IP \(bu 2
Flags: delayed, experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Thread idle threshold.
.sp
Threads in excess of thread_pool_min, which have been idle for at least this long, will be destroyed.
.SS thread_pools
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: pools
.IP \(bu 2
Default: 2
.IP \(bu 2
Minimum: 1
.IP \(bu 2
Flags: delayed, experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Number of worker thread pools.
.sp
Increasing number of worker pools decreases lock contention.
.sp
Too many pools waste CPU and RAM resources, and more than one pool for each CPU is probably detrimal to performance.
.sp
Can be increased on the fly, but decreases require a restart to take effect.
.SS thread_queue_limit
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: 20
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Permitted queue length per thread\-pool.
.sp
This sets the number of requests we will queue, waiting for an available thread.  Above this limit sessions will be dropped instead of queued.
.SS thread_stats_rate
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: requests
.IP \(bu 2
Default: 10
.IP \(bu 2
Minimum: 0
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Worker threads accumulate statistics, and dump these into the global stats counters if the lock is free when they finish a job (request/fetch etc.)
This parameters defines the maximum number of jobs a worker thread may handle, before it is forced to dump its accumulated stats into the global counters.
.SS timeout_idle
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 5.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Idle timeout for client connections.
A connection is considered idle, until we have received the full request headers.
.SS timeout_linger
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 0.050
.IP \(bu 2
Minimum: 0.000
.IP \(bu 2
Flags: experimental
.UNINDENT
.UNINDENT
.UNINDENT
.sp
How long the worker thread lingers on an idle session before handing it over to the waiter.
When sessions are reused, as much as half of all reuses happen within the first 100 msec of the previous request completing.
Setting this too high results in worker threads not doing anything for their keep, setting it too low just means that more sessions take a detour around the waiter.
.SS vcc_allow_inline_c
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: off
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Allow inline C code in VCL.
.SS vcc_err_unref
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Unreferenced VCL objects result in error.
.SS vcc_unsafe_path
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bool
.IP \(bu 2
Default: on
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Allow \(aq/\(aq in vmod & include paths.
Allow \(aqimport ... from ...\(aq.
.SS vcl_cooldown
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: seconds
.IP \(bu 2
Default: 600.000
.IP \(bu 2
Minimum: 0.000
.UNINDENT
.UNINDENT
.UNINDENT
.sp
How long a VCL is kept warm after being replaced as the active VCL (granularity approximately 30 seconds).
.SS vcl_dir
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: /opt/varnish/etc/varnish
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Directory (or colon separated list of directories) from which relative VCL filenames (vcl.load and include) are to be found.
.SS vmod_dir
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: /opt/varnish/lib/varnish/vmods
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Directory (or colon separated list of directories) where VMODs are to be found.
.SS vsl_buffer
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 4k
.IP \(bu 2
Minimum: 267
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Bytes of (req\-/backend\-)workspace dedicated to buffering VSL records.
Setting this too high costs memory, setting it too low will cause more VSL flushes and likely increase lock\-contention on the VSL mutex.
.sp
The minimum tracks the vsl_reclen parameter + 12 bytes.
.SS vsl_mask
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Default: \-VCL_trace,\-WorkThread,\-Hash,\-VfpAcct
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Mask individual VSL messages from being logged.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fIdefault\fP
Set default value
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Use +/\- prefix in front of VSL tag name, to mask/unmask individual VSL messages.
.SS vsl_reclen
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 255b
.IP \(bu 2
Minimum: 16b
.IP \(bu 2
Maximum: 4084b
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Maximum number of bytes in SHM log record.
.sp
The maximum tracks the vsl_buffer parameter \- 12 bytes.
.SS vsl_space
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 80M
.IP \(bu 2
Minimum: 1M
.IP \(bu 2
Flags: must_restart
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The amount of space to allocate for the VSL fifo buffer in the VSM memory segment.  If you make this too small, varnish{ncsa|log} etc will not be able to keep up.  Making it too large just costs memory resources.
.SS vsm_space
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 1M
.IP \(bu 2
Minimum: 1M
.IP \(bu 2
Flags: must_restart
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The amount of space to allocate for stats counters in the VSM memory segment.  If you make this too small, some counters will be invisible.  Making it too large just costs memory resources.
.SS workspace_backend
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 64k
.IP \(bu 2
Minimum: 1k
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Bytes of HTTP protocol workspace for backend HTTP req/resp.  If larger than 4k, use a multiple of 4k for VM efficiency.
.SS workspace_client
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 64k
.IP \(bu 2
Minimum: 9k
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Bytes of HTTP protocol workspace for clients HTTP req/resp.  If larger than 4k, use a multiple of 4k for VM efficiency.
.SS workspace_session
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 0.50k
.IP \(bu 2
Minimum: 0.25k
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Allocation size for session structure and workspace.    The workspace is primarily used for TCP connection addresses.  If larger than 4k, use a multiple of 4k for VM efficiency.
.SS workspace_thread
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Units: bytes
.IP \(bu 2
Default: 2k
.IP \(bu 2
Minimum: 0.25k
.IP \(bu 2
Maximum: 8k
.IP \(bu 2
Flags: delayed
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Bytes of auxiliary workspace per thread.
This workspace is used for certain temporary data structures during the operation of a worker thread.
One use is for the io\-vectors for writing requests and responses to sockets, having too little space will result in more writev(2) system calls, having too much just wastes the space.
.SH EXIT CODES
.sp
Varnish and bundled tools will, in most cases, exit with one of the
following codes
.INDENT 0.0
.IP \(bu 2
\fI0\fP OK
.IP \(bu 2
\fI1\fP Some error which could be system\-dependent and/or transient
.IP \(bu 2
\fI2\fP Serious configuration / parameter error \- retrying with the same
configuration / parameters is most likely useless
.UNINDENT
.sp
The \fIvarnishd\fP master process may also OR its exit code
.INDENT 0.0
.IP \(bu 2
with \fI0x20\fP when the \fIvarnishd\fP child process died,
.IP \(bu 2
with \fI0x40\fP when the \fIvarnishd\fP child process was terminated by a
signal and
.IP \(bu 2
with \fI0x80\fP when a core was dumped.
.UNINDENT
.SH SEE ALSO
.INDENT 0.0
.IP \(bu 2
\fIvarnishlog(1)\fP
.IP \(bu 2
\fIvarnishhist(1)\fP
.IP \(bu 2
\fIvarnishncsa(1)\fP
.IP \(bu 2
\fIvarnishstat(1)\fP
.IP \(bu 2
\fIvarnishtop(1)\fP
.IP \(bu 2
\fIvarnish\-cli(7)\fP
.IP \(bu 2
\fIvcl(7)\fP
.UNINDENT
.SH HISTORY
.sp
The \fIvarnishd\fP daemon was developed by Poul\-Henning Kamp in cooperation
with Verdens Gang AS and Varnish Software.
.sp
This manual page was written by Dag\-Erling Smørgrav with updates by
Stig Sandbeck Mathisen <\fI\%ssm@debian.org\fP>, Nils Goroll and others.
.SH COPYRIGHT
.sp
This document is licensed under the same licence as Varnish
itself. See LICENCE for details.
.INDENT 0.0
.IP \(bu 2
Copyright (c) 2007\-2015 Varnish Software AS
.UNINDENT
.\" Generated by docutils manpage writer.
.\" 
.
