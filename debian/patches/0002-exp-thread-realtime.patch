Origin: WMF
Description: Add exp_thread_rt and exp_lck_inherit parameters. These parameters have been used in the past
on varnish-be during the debugging of T145661 and maybe could be dropped.
Issue: https://phabricator.wikimedia.org/T145661
diff --git a/bin/varnishd/cache/cache.h b/bin/varnishd/cache/cache.h
index ee33de0..e0f0f6d 100644
--- a/bin/varnishd/cache/cache.h
+++ b/bin/varnishd/cache/cache.h
@@ -828,7 +828,7 @@ extern pthread_key_t witness_key;
 void Lck__Lock(struct lock *lck, const char *p,  int l);
 void Lck__Unlock(struct lock *lck, const char *p,  int l);
 int Lck__Trylock(struct lock *lck, const char *p,  int l);
-void Lck__New(struct lock *lck, struct VSC_C_lck *, const char *);
+void Lck__New(struct lock *lck, struct VSC_C_lck *, const char *, int protocol);
 int Lck__Held(const struct lock *lck);
 int Lck__Owned(const struct lock *lck);
 
@@ -836,7 +836,8 @@ int Lck__Owned(const struct lock *lck);
 void Lck_Delete(struct lock *lck);
 int Lck_CondWait(pthread_cond_t *cond, struct lock *lck, double);
 
-#define Lck_New(a, b) Lck__New(a, b, #b)
+#define Lck_New(a, b) Lck__New(a, b, #b, PTHREAD_PRIO_NONE)
+#define Lck_New_Inherit(a, b) Lck__New(a, b, #b, PTHREAD_PRIO_INHERIT)
 #define Lck_Lock(a) Lck__Lock(a, __func__, __LINE__)
 #define Lck_Unlock(a) Lck__Unlock(a, __func__, __LINE__)
 #define Lck_Trylock(a) Lck__Trylock(a, __func__, __LINE__)
diff --git a/bin/varnishd/cache/cache_expire.c b/bin/varnishd/cache/cache_expire.c
index f0ca523..fc16096 100644
--- a/bin/varnishd/cache/cache_expire.c
+++ b/bin/varnishd/cache/cache_expire.c
@@ -33,6 +33,7 @@
 #include "config.h"
 
 #include <stdlib.h>
+#include <stdio.h>
 
 #include "cache.h"
 
@@ -307,6 +308,8 @@ exp_thread(struct worker *wrk, void *priv)
 	struct objcore *oc;
 	double t = 0, tnext = 0;
 	struct exp_priv *ep;
+	struct sched_param param;
+	int s;
 	unsigned flags = 0;
 
 	CAST_OBJ_NOTNULL(ep, priv, EXP_PRIV_MAGIC);
@@ -314,6 +317,17 @@ exp_thread(struct worker *wrk, void *priv)
 	VSL_Setup(&ep->vsl, NULL, 0);
 	ep->heap = binheap_new(NULL, object_cmp, object_update);
 	AN(ep->heap);
+
+        if (cache_param->exp_thread_rt) {
+                // Pick a realtime policy scheduling (SCHED_FIFO) and bump prio
+                param.sched_priority = 1;
+                s = pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+                if (s != 0) {
+                        perror("pthread_getschedparam");
+                        exit(EXIT_FAILURE);
+                }
+        }
+
 	while (1) {
 
 		Lck_Lock(&ep->mtx);
@@ -357,7 +371,12 @@ EXP_Init(void)
 	ALLOC_OBJ(ep, EXP_PRIV_MAGIC);
 	AN(ep);
 
-	Lck_New(&ep->mtx, lck_exp);
+	if (cache_param->exp_lck_inherit) {
+		Lck_New_Inherit(&ep->mtx, lck_exp);
+	} else {
+		Lck_New(&ep->mtx, lck_exp);
+	}
+
 	AZ(pthread_cond_init(&ep->condvar, NULL));
 	VSTAILQ_INIT(&ep->inbox);
 	AZ(pthread_rwlock_init(&ep->cb_rwl, NULL));
diff --git a/bin/varnishd/cache/cache_lck.c b/bin/varnishd/cache/cache_lck.c
index 609971a..d18a0d8 100644
--- a/bin/varnishd/cache/cache_lck.c
+++ b/bin/varnishd/cache/cache_lck.c
@@ -214,7 +214,7 @@ Lck_CondWait(pthread_cond_t *cond, struct lock *lck, double when)
 }
 
 void
-Lck__New(struct lock *lck, struct VSC_C_lck *st, const char *w)
+Lck__New(struct lock *lck, struct VSC_C_lck *st, const char *w, int protocol)
 {
 	struct ilck *ilck;
 
@@ -226,6 +226,10 @@ Lck__New(struct lock *lck, struct VSC_C_lck *st, const char *w)
 	ilck->w = w;
 	ilck->stat = st;
 	ilck->stat->creat++;
+
+	// Valid values: PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, PTHREAD_PRIO_PROTECT
+	pthread_mutexattr_setprotocol(&attr, protocol);
+
 	AZ(pthread_mutex_init(&ilck->mtx, &attr));
 	lck->priv = ilck;
 }
diff --git a/include/tbl/params.h b/include/tbl/params.h
index a44b625..21a5b49 100644
--- a/include/tbl/params.h
+++ b/include/tbl/params.h
@@ -467,6 +467,34 @@ PARAM(
 	/* func */	NULL
 )
 
+PARAM(
+	/* name */	exp_thread_rt,
+	/* typ */	bool,
+	/* min */	NULL,
+	/* max */	NULL,
+	/* default */	"off",
+	/* units */	"bool",
+	/* flags */	MUST_RESTART | EXPERIMENTAL,
+	/* s-text */
+	"Use a realtime scheduling policy for expiry thread.",
+	/* l-text */	NULL,
+	/* func */	NULL
+)
+
+PARAM(
+	/* name */	exp_lck_inherit,
+	/* typ */	bool,
+	/* min */	NULL,
+	/* max */	NULL,
+	/* default */	"off",
+	/* units */	"bool",
+	/* flags */	MUST_RESTART | EXPERIMENTAL,
+	/* s-text */
+	"Set expiry thread lock mutex protocol to PTHREAD_PRIO_INHERIT.",
+	/* l-text */	NULL,
+	/* func */	NULL
+)
+
 #if 0
 /* actual location mgt_param_bits.c*/
 /* See tbl/feature_bits.h */
