This patch reverts 8b7cb51b76ad616143040ee955f1f6d9306251b9:

Allow grace-hits on hit-for-pass objects, and treat the first one (which gets
the busyobj) as a miss. See https://phabricator.wikimedia.org/T134989.

diff --git a/bin/varnishd/cache/cache_hash.c b/bin/varnishd/cache/cache_hash.c
index 4355cc6..a88c5c9 100644
--- a/bin/varnishd/cache/cache_hash.c
+++ b/bin/varnishd/cache/cache_hash.c
@@ -441,7 +441,8 @@ HSH_Lookup(struct req *req, struct objcore **ocp, struct objcore **bocp,
 			*ocp = oc;
 			return (HSH_HIT);
 		}
-		if (oc->exp.t_origin > exp_t_origin) {
+		if (oc->exp.t_origin > exp_t_origin &&
+		    !(oc->flags & OC_F_PASS)) {
 			/* record the newest object */
 			exp_oc = oc;
 			exp_t_origin = oc->exp.t_origin;
diff --git a/bin/varnishd/cache/cache_req_fsm.c b/bin/varnishd/cache/cache_req_fsm.c
index 1a59ae2..c21e850 100644
--- a/bin/varnishd/cache/cache_req_fsm.c
+++ b/bin/varnishd/cache/cache_req_fsm.c
@@ -404,17 +404,12 @@ cnt_lookup(struct worker *wrk, struct req *req)
 	AZ(oc->flags & OC_F_BUSY);
 	req->objcore = oc;
 
-	if ((oc->flags & OC_F_PASS) && boc != NULL) {
-		/* Treat a graced Hit-For-Pass as a miss */
-		req->objcore = boc;
-		req->stale_oc = oc;
-		req->req_step = R_STP_MISS;
-		return (REQ_FSM_MORE);
-	} else if (oc->flags & OC_F_PASS) {
+	if (oc->flags & OC_F_PASS) {
 		/* Found a hit-for-pass */
 		VSLb(req->vsl, SLT_Debug, "XXXX HIT-FOR-PASS");
 		VSLb(req->vsl, SLT_HitPass, "%u",
 		    ObjGetXID(wrk, req->objcore));
+		AZ(boc);
 		(void)HSH_DerefObjCore(wrk, &req->objcore);
 		wrk->stats->cache_hitpass++;
 		req->req_step = R_STP_PASS;
