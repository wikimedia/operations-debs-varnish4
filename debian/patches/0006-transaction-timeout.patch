--- a/bin/varnishd/cache/cache.h
+++ b/bin/varnishd/cache/cache.h
@@ -232,6 +232,13 @@
 	/* Timeouts */
 	double			first_byte_timeout;
 	double			between_bytes_timeout;
+	double			transaction_timeout;
+
+	/*
+	 * Only set on backend conns, to bo.t_first+transaction_timeout,
+         * iff transaction_timeout is non-zero
+	 */
+	double			abs_transaction_timeout;
 };
 
 /*--------------------------------------------------------------------*/
@@ -487,6 +494,7 @@
 	double			connect_timeout;
 	double			first_byte_timeout;
 	double			between_bytes_timeout;
+	double			transaction_timeout;
 
 	/* Timers */
 	double			t_first;	/* First timestamp logged */
@@ -966,7 +974,7 @@
 void HTC_RxInit(struct http_conn *htc, struct ws *ws);
 void HTC_RxPipeline(struct http_conn *htc, void *);
 enum htc_status_e HTC_RxStuff(struct http_conn *, htc_complete_f *,
-    double *t1, double *t2, double ti, double tn, int maxbytes);
+    double *t1, double *t2, double ti, double tn, double ta, int maxbytes);
 
 #define SESS_ATTR(UP, low, typ, len)					\
 	int SES_Set_##low(const struct sess *sp, const typ *src);	\
--- a/bin/varnishd/cache/cache_backend.c
+++ b/bin/varnishd/cache/cache_backend.c
@@ -124,6 +124,8 @@
 	    bo->htc->first_byte_timeout, bo, bp);
 	FIND_TMO(between_bytes_timeout,
 	    bo->htc->between_bytes_timeout, bo, bp);
+	FIND_TMO(transaction_timeout,
+	    bo->htc->transaction_timeout, bo, bp);
 	return (vc);
 }
 
--- a/bin/varnishd/cache/cache_panic.c
+++ b/bin/varnishd/cache/cache_panic.c
@@ -202,6 +202,8 @@
 	    htc->first_byte_timeout);
 	VSB_printf(vsb, "between_bytes_timeout = %f,\n",
 	    htc->between_bytes_timeout);
+	VSB_printf(vsb, "transaction_timeout = %f,\n",
+	    htc->transaction_timeout);
 	VSB_indent(vsb, -2);
 	VSB_printf(vsb, "},\n");
 }
--- a/bin/varnishd/cache/cache_session.c
+++ b/bin/varnishd/cache/cache_session.c
@@ -228,11 +228,14 @@
  * *t2 becomes time of complete rx
  * ti is when we return IDLE if nothing has arrived
  * tn is when we timeout on non-complete
+ * ta is when we timeout absolutely (once per received chunk, where each chunk
+ *   is limited to tn seconds of wait time, we check if VTIM_real() has passed
+ *   this timestamp and return TIMEOUT if so).  0 to not use this timeout.
  */
 
 enum htc_status_e
 HTC_RxStuff(struct http_conn *htc, htc_complete_f *func,
-    double *t1, double *t2, double ti, double tn, int maxbytes)
+    double *t1, double *t2, double ti, double tn, double ta, int maxbytes)
 {
 	double tmo;
 	double now;
@@ -288,6 +291,11 @@
 		else
 			WRONG("htc_status_e");
 
+		if (ta && now >= ta) {
+			WS_ReleaseP(htc->ws, htc->rxbuf_b);
+			return (HTC_S_TIMEOUT);
+		}
+
 		tmo = tn - now;
 		if (!isnan(ti) && ti < tn)
 			tmo = ti - now;
--- a/bin/varnishd/cache/cache_vrt_var.c
+++ b/bin/varnishd/cache/cache_vrt_var.c
@@ -289,6 +289,7 @@
 BEREQ_TIMEOUT(connect_timeout)
 BEREQ_TIMEOUT(first_byte_timeout)
 BEREQ_TIMEOUT(between_bytes_timeout)
+BEREQ_TIMEOUT(transaction_timeout)
 
 /*--------------------------------------------------------------------*/
 
--- a/bin/varnishd/http1/cache_http1_fetch.c
+++ b/bin/varnishd/http1/cache_http1_fetch.c
@@ -161,12 +161,20 @@
 	CHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);
 	CHECK_OBJ_NOTNULL(bo->htc, HTTP_CONN_MAGIC);
 
+	if (htc->transaction_timeout)
+		htc->abs_transaction_timeout =
+		    bo->t_first + htc->transaction_timeout;
+	else
+		htc->abs_transaction_timeout = 0;
+
 	t = VTIM_real() + htc->first_byte_timeout;
 	hs = HTC_RxStuff(htc, HTTP1_Complete, NULL, NULL,
-	    t, t + htc->between_bytes_timeout, cache_param->http_resp_size);
+	    t, t + htc->between_bytes_timeout, htc->abs_transaction_timeout,
+	    cache_param->http_resp_size);
 	if (hs != HTC_S_COMPLETE) {
 		bo->acct.beresp_hdrbytes +=
 		    htc->rxbuf_e - htc->rxbuf_b;
+		htc->abs_transaction_timeout = 0;
 		switch (hs) {
 		case HTC_S_JUNK:
 			VSLb(bo->vsl, SLT_FetchError, "Received junk");
--- a/bin/varnishd/http1/cache_http1_fsm.c
+++ b/bin/varnishd/http1/cache_http1_fsm.c
@@ -396,7 +396,7 @@
 			hs = HTC_RxStuff(req->htc, HTTP1_Complete,
 			    &req->t_first, &req->t_req,
 			    sp->t_idle + cache_param->timeout_linger,
-			    sp->t_idle + cache_param->timeout_idle,
+			    sp->t_idle + cache_param->timeout_idle, 0,
 			    cache_param->http_req_size);
 			AZ(req->htc->ws->r);
 			if (hs < HTC_S_EMPTY) {
--- a/bin/varnishd/http1/cache_http1_vfp.c
+++ b/bin/varnishd/http1/cache_http1_vfp.c
@@ -43,6 +43,7 @@
 #include "cache_http1.h"
 
 #include "vct.h"
+#include "vtim.h"
 
 /*--------------------------------------------------------------------
  * Read up to len bytes, returning pipelined data first.
@@ -73,6 +74,18 @@
 			htc->pipeline_b = htc->pipeline_e = NULL;
 	}
 	if (len > 0) {
+		// check transaction timeout before we do another blocking read()
+		if (htc->abs_transaction_timeout) {
+			// possible perf impact here with a new clock_gettime()
+			// syscall before every body read() syscall on backend
+			// conns, but I think on modern x86_64 kernels this is a
+			// vsyscall, and even if not it's probably acceptable in
+			// the overall?
+			if (VTIM_real() >= htc->abs_transaction_timeout) {
+				VSLb(vc->wrk->vsl, SLT_FetchError, "Transaction Timeout");
+				return -1;
+			}
+		}
 		i = read(*htc->rfd, p, len);
 		if (i < 0) {
 			// XXX: VTCP_Assert(i); // but also: EAGAIN
--- a/bin/varnishd/http2/cache_http2_proto.c
+++ b/bin/varnishd/http2/cache_http2_proto.c
@@ -867,7 +867,7 @@
 	h2->sess->t_idle = VTIM_real();
 	hs = HTC_RxStuff(h2->htc, h2_frame_complete,
 	    NULL, NULL, NAN,
-	    h2->sess->t_idle + cache_param->timeout_idle + 100,
+	    h2->sess->t_idle + cache_param->timeout_idle + 100, 0,
 	    16384 + 9);					// rfc7540,l,4228,4228
 	if (hs != HTC_S_COMPLETE) {
 		Lck_Lock(&h2->sess->mtx);
--- a/bin/varnishd/http2/cache_http2_session.c
+++ b/bin/varnishd/http2/cache_http2_session.c
@@ -238,7 +238,7 @@
 
 	/* Wait for PRISM response */
 	hs = HTC_RxStuff(h2->htc, H2_prism_complete,
-	    NULL, NULL, NAN, h2->sess->t_idle + cache_param->timeout_idle,
+	    NULL, NULL, NAN, h2->sess->t_idle + cache_param->timeout_idle, 0,
 	    sizeof H2_prism);
 	if (hs != HTC_S_COMPLETE) {
 		VSLb(h2->vsl, SLT_Debug, "H2: No/Bad OU PRISM (hs=%d)", hs);
--- a/bin/varnishd/proxy/cache_proxy_proto.c
+++ b/bin/varnishd/proxy/cache_proxy_proto.c
@@ -352,7 +352,7 @@
 
 	HTC_RxInit(req->htc, req->ws);
 	hs = HTC_RxStuff(req->htc, vpx_complete,
-	    NULL, NULL, NAN, sp->t_idle + cache_param->timeout_idle,
+	    NULL, NULL, NAN, sp->t_idle + cache_param->timeout_idle, 0,
 	    1024);			// XXX ?
 	if (hs != HTC_S_COMPLETE) {
 		Req_Release(req);
--- /dev/null
+++ b/bin/varnishtest/tests/b00051.vtc
@@ -0,0 +1,57 @@
+varnishtest "Check the transaction_timeout behaves from parameters"
+
+server s1 {
+	rxreq
+	send "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+} -start
+
+varnish v1 -vcl+backend {
+	sub vcl_backend_response {
+		set beresp.do_stream = false;
+	}
+} -start
+varnish v1 -cliok "param.set between_bytes_timeout 1"
+varnish v1 -cliok "param.set transaction_timeout 2.75"
+
+client c1 {
+	txreq
+	rxresp
+	expect resp.status == 503
+} -run
+
+server s1 {
+	rxreq
+	send "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+} -start
+
+client c1 {
+	txreq
+	timeout 10
+	rxresp
+	expect resp.status == 200
+	expect resp.bodylen == 25
+} -run
--- /dev/null
+++ b/bin/varnishtest/tests/b00052.vtc
@@ -0,0 +1,59 @@
+varnishtest "Check the transaction_timeout behaves from vcl"
+
+server s1 {
+	rxreq
+	send "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+} -start
+
+varnish v1 -vcl+backend {
+	sub vcl_backend_fetch {
+		set bereq.between_bytes_timeout = 1s;
+		set bereq.transaction_timeout = 2.75s;
+	}
+	sub vcl_backend_response {
+		set beresp.do_stream = false;
+	}
+} -start
+
+client c1 {
+	txreq
+	rxresp
+	expect resp.status == 503
+} -run
+
+server s1 {
+	rxreq
+	send "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+} -start
+
+client c1 {
+	txreq
+	timeout 10
+	rxresp
+	expect resp.status == 200
+	expect resp.bodylen == 25
+} -run
--- /dev/null
+++ b/bin/varnishtest/tests/b00053.vtc
@@ -0,0 +1,61 @@
+varnishtest "Check the transaction_timeout behaves from backend definition"
+
+server s1 {
+	rxreq
+	send "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+} -start
+
+varnish v1 -vcl {
+	backend b1 {
+		.host = "${s1_addr}";
+		.port = "${s1_port}";
+		.between_bytes_timeout = 1s;
+		.transaction_timeout = 2.75s;
+	}
+	sub vcl_backend_response {
+		set beresp.do_stream = false;
+	}
+} -start
+
+client c1 {
+	txreq
+	rxresp
+	expect resp.status == 503
+} -run
+
+server s1 {
+	rxreq
+	send "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+	delay 0.5
+	send "Baba\n"
+} -start
+
+client c1 {
+	txreq
+	timeout 10
+	rxresp
+	expect resp.status == 200
+	expect resp.bodylen == 25
+} -run
--- a/doc/sphinx/include/params.rst
+++ b/doc/sphinx/include/params.rst
@@ -1035,6 +1035,20 @@
 When sessions are reused, as much as half of all reuses happen within the first 100 msec of the previous request completing.
 Setting this too high results in worker threads not doing anything for their keep, setting it too low just means that more sessions take a detour around the waiter.
 
+.. _ref_param_transaction_timeout:
+
+transaction_timeout
+~~~~~~~~~~~~~~~~~~~
+	* Units: seconds
+	* Default: 0.000
+	* Minimum: 0.000
+
+Timeout for whole response received from backend.
+May be late by up to between_bytes_timeout due to implementation details.  Not available in pipe mode.
+A value of zero means never give up.
+VCL values, per backend or per backend request take precedence.
+This parameter does not apply to pipe'ed requests.
+
 .. _ref_param_vcc_allow_inline_c:
 
 vcc_allow_inline_c
--- a/doc/sphinx/include/vcl_var.rst
+++ b/doc/sphinx/include/vcl_var.rst
@@ -123,6 +123,21 @@
 	A count of how many times this request has been retried.
 	
 
+bereq.transaction_timeout
+
+	Type: DURATION
+
+	Readable from: backend
+
+	Writable from: backend
+
+	
+	Timeout for whole response received from backend.  May
+	be late by up to between_bytes_timeout due to
+	implementation details.  Not available in pipe mode.
+	A value of zero means never give up.
+	
+
 bereq.uncacheable
 
 	Type: BOOL
--- a/include/tbl/params.h
+++ b/include/tbl/params.h
@@ -264,6 +264,25 @@
 )
 
 PARAM(
+	/* name */	transaction_timeout,
+	/* typ */	timeout,
+	/* min */	"0",
+	/* max */	NULL,
+	/* default */	"0",
+	/* units */	"seconds",
+	/* flags */	0,
+	/* s-text */
+	"Timeout for whole response received from backend.\n"
+	"May be late by up to between_bytes_timeout due to "
+	"implementation details.  Not available in pipe mode.\n"
+	"A value of zero means never give up.\n"
+	"VCL values, per backend or per backend request take precedence.\n"
+	"This parameter does not apply to pipe'ed requests.",
+	/* l-text */	"",
+	/* func */	NULL
+)
+
+PARAM(
 	/* name */	backend_idle_timeout,
 	/* typ */	timeout,
 	/* min */	"1",
--- a/include/vrt.h
+++ b/include/vrt.h
@@ -207,6 +207,7 @@
 	double				connect_timeout;	\
 	double				first_byte_timeout;	\
 	double				between_bytes_timeout;	\
+	double				transaction_timeout;	\
 	unsigned			max_connections;	\
 	unsigned			proxy_header;
 
@@ -220,6 +221,7 @@
 		DN(connect_timeout);		\
 		DN(first_byte_timeout);		\
 		DN(between_bytes_timeout);	\
+		DN(transaction_timeout);	\
 		DN(max_connections);		\
 		DN(proxy_header);		\
 	} while(0)
--- a/include/vrt_obj.h
+++ b/include/vrt_obj.h
@@ -30,6 +30,9 @@
 
 VCL_INT VRT_r_bereq_retries(VRT_CTX);
 
+VCL_DURATION VRT_r_bereq_transaction_timeout(VRT_CTX);
+void VRT_l_bereq_transaction_timeout(VRT_CTX, VCL_DURATION);
+
 VCL_BOOL VRT_r_bereq_uncacheable(VRT_CTX);
 
 VCL_STRING VRT_r_bereq_url(VRT_CTX);
--- a/lib/libvcc/generate.py
+++ b/lib/libvcc/generate.py
@@ -479,6 +479,16 @@
 		backend.  Not available in pipe mode.
 		"""
 	),
+	('bereq.transaction_timeout',
+		'DURATION',
+		('backend', ),
+		('backend', ), """
+		Timeout for whole response received from backend.  May
+		be late by up to between_bytes_timeout due to
+		implementation details.  Not available in pipe mode.
+		A value of zero means never give up.
+		"""
+	),
 	('beresp',
 		'HTTP',
 		('backend_response', 'backend_error'),
--- a/lib/libvcc/vcc_backend.c
+++ b/lib/libvcc/vcc_backend.c
@@ -297,6 +297,7 @@
 	    "?connect_timeout",
 	    "?first_byte_timeout",
 	    "?between_bytes_timeout",
+	    "?transaction_timeout",
 	    "?probe",
 	    "?max_connections",
 	    "?proxy_header",
@@ -366,6 +367,12 @@
 			vcc_Duration(tl, &t);
 			ERRCHK(tl);
 			Fb(tl, 0, "%g,\n", t);
+			SkipToken(tl, ';');
+		} else if (vcc_IdIs(t_field, "transaction_timeout")) {
+			Fb(tl, 0, "\t.transaction_timeout = ");
+			vcc_Duration(tl, &t);
+			ERRCHK(tl);
+			Fb(tl, 0, "%g,\n", t);
 			SkipToken(tl, ';');
 		} else if (vcc_IdIs(t_field, "max_connections")) {
 			u = vcc_UintVal(tl);
--- a/lib/libvcc/vcc_fixed_token.c
+++ b/lib/libvcc/vcc_fixed_token.c
@@ -371,20 +371,21 @@
 	    "\t\t*port;\t\t\t\\\n\trigid char\t\t\t*hosthdr;\t\t\\\n"
 	    "\tdouble\t\t\t\tconnect_timeout;\t\\\n\tdouble\t\t\t\tfirst_byte"
 	    "_timeout;\t\\\n\tdouble\t\t\t\tbetween_bytes_timeout;\t\\\n"
-	    "\tunsigned\t\t\tmax_connections;\t\\\n\tunsigned\t\t\tproxy_head"
-	    "er;\n\n#define VRT_BACKEND_HANDLE()\t\t\t\\\n\tdo {\t\t\t\t"
-	    "\t\\\n\t\tDA(vcl_name);\t\t\t\\\n\t\tDA(ipv4_addr);\t\t\t\\\n"
+	    "\tdouble\t\t\t\ttransaction_timeout;\t\\\n\tunsigned\t\t\tmax_co"
+	    "nnections;\t\\\n\tunsigned\t\t\tproxy_header;\n\n"
+	    "#define VRT_BACKEND_HANDLE()\t\t\t\\\n\tdo {\t\t\t\t\t\\\n"
+	    "\t\tDA(vcl_name);\t\t\t\\\n\t\tDA(ipv4_addr);\t\t\t\\\n"
 	    "\t\tDA(ipv6_addr);\t\t\t\\\n\t\tDA(port);\t\t\t\\\n"
 	    "\t\tDA(hosthdr);\t\t\t\\\n\t\tDN(connect_timeout);\t\t\\\n"
 	    "\t\tDN(first_byte_timeout);\t\t\\\n\t\tDN(between_bytes_timeout)"
-	    ";\t\\\n\t\tDN(max_connections);\t\t\\\n\t\tDN(proxy_header);\t"
-	    "\t\\\n\t} while(0)\n\nstruct vrt_backend {\n\tunsigned\t\t\t"
-	    "magic;\n#define VRT_BACKEND_MAGIC\t\t0x4799ce6b\n"
-	    "\tVRT_BACKEND_FIELDS(const)\n\tconst struct suckaddr\t\t*ipv4_su"
-	    "ckaddr;\n\tconst struct suckaddr\t\t*ipv6_suckaddr;\n"
-	    "\tconst struct vrt_backend_probe\t*probe;\n};\n\n"
-	    "#define VRT_BACKEND_PROBE_FIELDS(rigid)\t\t\t\t\\\n"
-	    "\tdouble\t\t\t\ttimeout;\t\t\\\n\tdouble\t\t\t\tinterval;\t"
+	    ";\t\\\n\t\tDN(transaction_timeout);\t\\\n\t\tDN(max_connections)"
+	    ";\t\t\\\n\t\tDN(proxy_header);\t\t\\\n\t} while(0)\n"
+	    "\nstruct vrt_backend {\n\tunsigned\t\t\tmagic;\n#define VRT_BACK"
+	    "END_MAGIC\t\t0x4799ce6b\n\tVRT_BACKEND_FIELDS(const)\n"
+	    "\tconst struct suckaddr\t\t*ipv4_suckaddr;\n\tconst struct "
+	    "suckaddr\t\t*ipv6_suckaddr;\n\tconst struct vrt_backend_probe\t"
+	    "*probe;\n};\n\n#define VRT_BACKEND_PROBE_FIELDS(rigid)\t\t\t"
+	    "\t\\\n\tdouble\t\t\t\ttimeout;\t\t\\\n\tdouble\t\t\t\tinterval;\t"
 	    "\t\\\n\tunsigned\t\t\texp_status;\t\t\\\n\tunsigned\t\t\twindow;"
 	    "\t\t\t\\\n\tunsigned\t\t\tthreshold;\t\t\\\n\tunsigned\t\t\t"
 	    "initial;\n\n#define VRT_BACKEND_PROBE_HANDLE()\t\t\\\n"
@@ -435,20 +436,20 @@
 	    "const char *file_id, const char *backup);\nvoid VRT_Vmod_Fini(st"
 	    "ruct vmod **hdl);\n\n/* VCL program related */\nVCL_VCL VRT_vcl_"
 	    "get(VRT_CTX, const char *);\nvoid VRT_vcl_rel(VRT_CTX, VCL_VCL);"
-	    "\nvoid VRT_vcl_select(VRT_CTX, VCL_VCL);\n\nstruct vmod_priv;\n"
-	    "typedef void vmod_priv_free_f(void *);\nstruct vmod_pri");
-	VSB_cat(sb, "v {\n\tvoid\t\t\t*priv;\n\tint\t\t\tlen;\n"
-	    "\tvmod_priv_free_f\t*free;\n};\n\n#ifdef VCL_RET_MAX\n"
-	    "typedef int vmod_event_f(VRT_CTX, struct vmod_priv *, enum "
-	    "vcl_event_e);\n#endif\n\nstruct vclref;\nstruct vclref * VRT_ref"
-	    "_vcl(VRT_CTX, const char *);\nvoid VRT_rel_vcl(VRT_CTX, struct "
-	    "vclref **);\n\nvoid VRT_priv_fini(const struct vmod_priv *p);\n"
-	    "struct vmod_priv *VRT_priv_task(VRT_CTX, void *vmod_id);\n"
-	    "struct vmod_priv *VRT_priv_top(VRT_CTX, void *vmod_id);\n"
-	    "\n/* Stevedore related functions */\nint VRT_Stv(const char "
-	    "*nm);\nVCL_STEVEDORE VRT_stevedore(const char *nm);\n"
-	    "\n/* Convert things to string */\n\nchar *VRT_IP_string(VRT_CTX,"
-	    " VCL_IP);\nchar *VRT_INT_string(VRT_CTX, VCL_INT);\n"
+	    "\nvoid VRT_vcl_select(VRT_CTX, VCL_VCL)");
+	VSB_cat(sb, ";\n\nstruct vmod_priv;\ntypedef void vmod_priv_free_"
+	    "f(void *);\nstruct vmod_priv {\n\tvoid\t\t\t*priv;\n"
+	    "\tint\t\t\tlen;\n\tvmod_priv_free_f\t*free;\n};\n"
+	    "\n#ifdef VCL_RET_MAX\ntypedef int vmod_event_f(VRT_CTX, struct "
+	    "vmod_priv *, enum vcl_event_e);\n#endif\n\nstruct vclref;\n"
+	    "struct vclref * VRT_ref_vcl(VRT_CTX, const char *);\n"
+	    "void VRT_rel_vcl(VRT_CTX, struct vclref **);\n\nvoid VRT_priv_fi"
+	    "ni(const struct vmod_priv *p);\nstruct vmod_priv *VRT_priv_task("
+	    "VRT_CTX, void *vmod_id);\nstruct vmod_priv *VRT_priv_top(VRT_CTX"
+	    ", void *vmod_id);\n\n/* Stevedore related functions */\n"
+	    "int VRT_Stv(const char *nm);\nVCL_STEVEDORE VRT_stevedore(const "
+	    "char *nm);\n\n/* Convert things to string */\n\nchar *VRT_IP_str"
+	    "ing(VRT_CTX, VCL_IP);\nchar *VRT_INT_string(VRT_CTX, VCL_INT);\n"
 	    "char *VRT_REAL_string(VRT_CTX, VCL_REAL);\nchar *VRT_TIME_string"
 	    "(VRT_CTX, VCL_TIME);\nconst char *VRT_BOOL_string(VCL_BOOL);\n"
 	    "const char *VRT_BACKEND_string(VCL_BACKEND);\nconst char *VRT_ST"
@@ -475,9 +476,11 @@
 	    "thod(VRT_CTX, const char *, ...);\n\nVCL_STRING VRT_r_bereq_prot"
 	    "o(VRT_CTX);\nvoid VRT_l_bereq_proto(VRT_CTX, const char *, "
 	    "...);\n\nVCL_INT VRT_r_bereq_retries(VRT_CTX);\n\n"
-	    "VCL_BOOL VRT_r_bereq_uncacheable(VRT_CTX);\n\nVCL_STRING VRT_r_b"
-	    "ereq_url(VRT_CTX);\nvoid VRT_l_bereq_url(VRT_CTX, const char "
-	    "*, ...);\n\nVCL_STRING VRT_r_bereq_xid(VRT_CTX);\n"
+	    "VCL_DURATION VRT_r_bereq_transaction_timeout(VRT_CTX);\n"
+	    "void VRT_l_bereq_transaction_timeout(VRT_CTX, VCL_DURATION);\n"
+	    "\nVCL_BOOL VRT_r_bereq_uncacheable(VRT_CTX);\n\nVCL_STRING "
+	    "VRT_r_bereq_url(VRT_CTX);\nvoid VRT_l_bereq_url(VRT_CTX, const "
+	    "char *, ...);\n\nVCL_STRING VRT_r_bereq_xid(VRT_CTX);\n"
 	    "\nVCL_HTTP VRT_r_beresp(VRT_CTX);\n\nVCL_DURATION VRT_r_beresp_a"
 	    "ge(VRT_CTX);\n\nVCL_BACKEND VRT_r_beresp_backend(VRT_CTX);\n"
 	    "\nVCL_IP VRT_r_beresp_backend_ip(VRT_CTX);\n\nVCL_STRING VRT_r_b"
--- a/lib/libvcc/vcc_obj.c
+++ b/lib/libvcc/vcc_obj.c
@@ -88,6 +88,14 @@
 	    NULL,	/* No writes allowed */
 		0,
 	},
+	{ "bereq.transaction_timeout", DURATION,
+	    "VRT_r_bereq_transaction_timeout(ctx)",
+		VCL_MET_BACKEND_ERROR | VCL_MET_BACKEND_FETCH
+		 | VCL_MET_BACKEND_RESPONSE,
+	    "VRT_l_bereq_transaction_timeout(ctx, ",
+		VCL_MET_BACKEND_ERROR | VCL_MET_BACKEND_FETCH
+		 | VCL_MET_BACKEND_RESPONSE,
+	},
 	{ "bereq.uncacheable", BOOL,
 	    "VRT_r_bereq_uncacheable(ctx)",
 		VCL_MET_BACKEND_ERROR | VCL_MET_BACKEND_FETCH
--- a/man/varnishd.1
+++ b/man/varnishd.1
@@ -1898,6 +1898,25 @@
 How long the worker thread lingers on an idle session before handing it over to the waiter.
 When sessions are reused, as much as half of all reuses happen within the first 100 msec of the previous request completing.
 Setting this too high results in worker threads not doing anything for their keep, setting it too low just means that more sessions take a detour around the waiter.
+.SS transaction_timeout
+.INDENT 0.0
+.INDENT 3.5
+.INDENT 0.0
+.IP \(bu 2
+Units: seconds
+.IP \(bu 2
+Default: 0.000
+.IP \(bu 2
+Minimum: 0.000
+.UNINDENT
+.UNINDENT
+.UNINDENT
+.sp
+Timeout for whole response received from backend.
+May be late by up to between_bytes_timeout due to implementation details.  Not available in pipe mode.
+A value of zero means never give up.
+VCL values, per backend or per backend request take precedence.
+This parameter does not apply to pipe\(aqed requests.
 .SS vcc_allow_inline_c
 .INDENT 0.0
 .INDENT 3.5
--- a/man/vcl.7
+++ b/man/vcl.7
@@ -598,6 +598,20 @@
 .UNINDENT
 .UNINDENT
 .sp
+bereq.transaction_timeout
+.INDENT 0.0
+.INDENT 3.5
+Type: DURATION
+.sp
+Readable from: backend
+.sp
+Writable from: backend
+.sp
+The time in seconds to wait for whole transaction complete w/
+backend.  Not available in pipe mode.
+.UNINDENT
+.UNINDENT
+.sp
 bereq.uncacheable
 .INDENT 0.0
 .INDENT 3.5
